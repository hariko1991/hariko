1.为了实现字符串池        
2.为了线程安全        
3.为了实现String可以创建HashCode不可变性    


首先你要理解final的用途，在分析String为什么要用final修饰，final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，
即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。
在了解final的用途后，在看String为什么要被final修饰：主要是为了”安全性“和”效率“的缘故。查看JDK String的源码





final修饰的String，代表了String的不可继承性，final修饰的char[]代表了被存储的数据不可更改性。但是：虽然final代表了不可变，但仅仅是引用地址不可变，并不代表了数组本身不会变,请看下面图片。





final也可以将数组本身改变的，这个时候，起作用的还有private，正是因为两者保证了String的不可变性。    
那么为什么保证String不可变呢,因为只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。
但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。    
如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。
因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。    因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。
这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。    
因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。
这就是HashMap中的键往往都使用字符串。



Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
 

抽象类可以在不提供接口方法实现的情况下实现接口。?
Java接口中声明的变量默认都是final的。(为什么)抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。
也可以参考JDK8中抽象类和接口的区别
 
 
 
问题1.Java接口中声明的变量默认都是final的。(为什么)
interface中的变量是当作常量来设计的，它不但是final，而且还是public static的，也即interface中的变量一定是public static final的，换言之，这个变量实际上已经是个“常量”。
解答:java接口中成员变量必须是final类型的原因如下：

1. 接口中的数据对所有实现类只有一份,所以是static
2.要使实现类为了向上转型成功,所以必须是final的.这个举例子很好理解.比如接口A,A有变量value.实现类A1,A2,可以向上转型.假如代码中有一句:
 

  A a=null;
     a=....(2)实际实现类
   System.out.println(a.value);
   利用向上转型,可以得到接口a的值,在第2步中,我不关你是实现类A1,还是new A2(),通过转型,我们可以得到正确的值.要是类中可以更改,我们得不到一个统一的值,接口也没有了意义.

 

假设接口的成员变量x不是final的，且默认有值。

如果你在某接口的实现类A中把x改为其他值,(能够改掉接口中的 吗,假如是继承的父类呢)，那么另一个实现类B中对x有依赖的方法全部都出错了，这样接口还怎么能起到“模板”的作用呢



final关键字的含义
final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。
final关键字的好处

final关键字提高了性能。JVM和Java应用都会缓存final变量。
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
使用final关键字，JVM会对方法、变量及类进行优化。

关于final的重要知识点

final关键字可以用于成员变量、本地变量、方法以及类。
final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
你不能够对final变量再次赋值。
本地变量必须在声明时赋值。
在匿名类中所有变量都必须是final变量。
final方法不能被重写。
final类不能被继承。
final关键字不同于finally关键字，后者用于异常处理。
final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
接口中声明的所有变量本身是final的。
final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
final方法在编译阶段绑定，称为静态绑定(static binding)。
没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
按照Java代码惯例，final变量就是常量，而且通常常量名要大写。

String类不可变性的好处

只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。
如果字符串是可变的，那么会引起很严重的安全问题。因为字符串是不可变的，所以它的值是不可改变的，否则改变字符串指向的对象的值，造成安全漏洞。
因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。
类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。
因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。


接口中如果可能定义非final的变量的话，而方法又都是abstract的，这就自相矛盾了，有可变成员变量但对应的方法却无法操作这些变量，虽然可以直接修改这些静态成员变量的值，但所有实现类对应的值都被修改了，这跟抽象类有何区别? 
(不懂,抽象类是怎么样的,抽象类可以包含非final的变量。)又接口是一种更高层面的抽象，是一种规范、功能定义的声明，所有可变的东西都应该归属到实现类中，这样接口才能起到标准化、规范化的作用。所以接口中的属性必然是final的。
 