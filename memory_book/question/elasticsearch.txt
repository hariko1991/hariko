1.query是怎么分发到每个节点的？
QUERY_THEN_FETCH（默认）
a：客户端把请求发送给集群中的某一个节点，这个节点会把查询请求发送给所有分片去执行，
b：每个分片会把查询的数据(包含数据的分值,以及数据ID)返回给某一个 节点进行汇总，排序，取前10名
c：根据前10名的id到对应的分片查询数据的详细内容，返回给客户端

2.Elasticsearch使用上的优化有哪些？

3.怎么避免脑裂？
当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes为n/2+1）多半数，超过所有候选节点一半以上来解决脑裂问题；
 当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。
 
4.query和filter的区别？
filter: 仅仅只是按照 过滤出需要的数据，不计算任何相关度分数，对相关度没有任何影响
query: 会计算每个document相对于搜索条件的相关度，并按照相关度排序
filter ,不需要计算相关度分数，不需要按照相关度分数排序，同时内置的自动cache,最常使用的filter的数据
query,要计算相关度，按照分数进行排序，而且无法cache结果

5.Elasticsearch的缺点有哪些？你觉得可以在哪些地方进行改进？

6.Lucene加快查询的机制有哪些？

7.如何使用Lucene构建分布式索引？

8.说一下master节点选举算法
Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；
 对所有可以成为master的节点（候选主节点）（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。
 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。
 补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。
 
9.Elasticsearch出现OOM的场景遇到过吗？

10.说一下副本的作用。
a 备份数据保证高可用数据不丢失，高并发的时候参与数据查询
b 一般一个分片有1-2个副本即可保证高可用
c 副本多浪费存储空间、占用资源、影响性能
d 为保证高可用，副本数设置为2即可。要求集群至少要有3个节点，来分开存放主分片、副本。
如发现并发量大时，查询性能会下降，可增加副本数，来提升并发查询能力

11.每天2个TB的数据怎么规划集群？
方案一：
a 数据总量
数据总量是指集群需要存储的数据总大小，如果每天都有新数据入库，总量随之相应地增加。我们之所以要考虑数据总量，并非因为磁盘空间容量的限制，而是 JVM 内存的限制。
为了加快搜索速度，Lucene 需要将每个段的倒排索引都加载到 JVM 内存中，因此每一个 open 状态的索引都会在 JVM 中占据一部分常驻内存，这些是 GC 不掉的，而且这部分空间占用的比较大，并且由于堆内存不建议超过 32G，在磁盘使用率达到极限之前，JVM 占用量会先到达极限。
按照我们的经验，Elasticsearch 中 1TB 的 index 大约占用 2GB 的 JVM 内存，具体和字段数据类型及样本相关，有些会更多。一般情况下，我们可以按照这个比例来做规划。如果想要精确计算，业务可以根据自己的样本数据入库 1TB，然后查看分段所占的内存大小（实际上会比 REST 接口返回的值高一些）
curl -X GET "localhost:9200/_cat/nodes?v&h=name,segments.memory"
以 1TB 数据占用 2GB 内存，JVM 堆内存配置 31G ，垃圾回收器 CMS 为例，新生代建议配置 10G，old 区 21G，这 21G 内存分配一半给分段内存就已经很多了，想想看还没有做任何读写操作时 old 区就占用了一半，其他几个内存大户例如 bulk 缓冲，Query 缓存，indexing buffer，聚合计算等都可能会使用到 old 区内存，因此为了保证节点稳定，分段内存不超过 10G 比较好，换算成索引数据量为5TB。
因此，我们可以按照单个节点打开的索引数据总量不超过 5TB 来进行规划，如果预计入库 Elasticsearch 中的数据总量有 100TB 的数据（包括副分片所占用空间），那么数据节点的数量至少应该是: 100/5=20，此外出于冗余方面的考虑，还要多加一些数据节点。冗余节点的数量则和日增数据量以及故障转移能力相关。
可以看出这样规划出来的节点数是相对比较多的，带来比较高的成本预算。在新的 6.7 及以上的版本 Elasticsearch 增加了冻结索引的特性，这是一种冷索引机制，平时他可以不占内存，只有查询的时候才去加载到内存，虽然查询慢一些，但是节点可以持有更多的数据总量。
因此，如果你想要节点存储更多的数据量，在超出上述原则后，除了删除或 close 索引之外，一个新的选择是将它变成冻结状态。
b 单个结点持有最大分片数量
单个节点可以持有的最大分片数量并没有明确的界限，但是过多的分片数量会造成比较大的管理压力，官方给出的建议是，单个节点上所持有的分片数按 JVM 内存来计算：每 GB 的内存乘以 20。例如 JVM 内存为 30GB，那么分片数最大为：30*20=600个。当然分片数越少会越稳定。
但是使用这个参考值也会有些问题，当分片大小为 40GB 时，节点所持有的数据量为：40 * 600 = 24TB，按照 1TB 数据量占用 2GB JVM 内存来计算，所占用 JVM 内存为：24 * 2 = 48GB，已经远超 JVM 大小，因此我们认为一般情况下不必将单个节点可以持有的分片数量作为一个参考依据，只需要关心一个原则：让 JVM 占用率和 GC 时间保持在一个合理的范围。
考虑另一个极端情况，每个分片的数据量都很小，同样不必关心每个节点可以持有多少，对大量分片的管理属于主节点的压力。一般情况下，建议整个集群的分片数量建议不超过 10 万。
c 结点考虑
单独功能的结点
如果没有使用预处理功能，可以将读写请求都发送到协调节点。另外数据写入过程最好先进入 Kafka 之类的 MQ，来缓冲一下对集群的写入压力，同时也便于对集群的后期维护。



方案二：
a ES官方文档heap size里面有说：ES进程所使用的物理内存(Xms Xmx配置)不要超过机器物理内存的一半，同时考虑到指针压缩问题，分配给ES进程的内存不要超过32GB，一个安全的值是26GB（各个操作系统平台上，JVM进程26GB不会有指针压缩问题）
b 每个分片的大小推荐在20GB-40GB之间，我自己一般保证单个分片的大小不超过30GB
c 30G heap 大概能处理的数据量 10 T	

具体到一个索引应该配置多少个主分片，多少个副本分片？考虑一下这个索引是用来干什么的？这个索引的Mapping结构如何定义？哪些字段需要做搜索(index_options参数)？哪些字段做term查询(keyword 类型)、哪些字段需要Analyzer做Match查询(text 类型)、要不要聚合(是否开启doc_value)，要不要语法高亮(term_vector 和 positions 参数)，要不要禁用_source参数？
 一个合理的Mapping配置也是能够有效减少index 大小的。我们实际生产环境中，禁用doc_value之后，索引大小几乎减小了一半。

12.比较一下向量空间模型和概率检索模型的优缺点。

13.DocValues的作用。
a 关系逆置
b 列式存储
c Doc Values是在字段索引时与倒排索引同时生成。
d Doc Values与倒排索引一样基于Segement生成并且是不可变的。

14.一个索引下多个type可能会导致什么样的问题？
报错，因为是扁平化，最好用不一样的字段

15.Elasticsearch更新和删除文档是怎么做的？
删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；
 磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。
 在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。

16.Elasticsearch集群三种结点的角色 
•master node:master几点主要用于元数据(metadata)的处理，比如索引的新增、删除、分片分配等。
•data node:data 节点上保存了数据分片。它负责数据相关操作，比如分片的 CRUD，以及搜索和整合操作。这些操作都比较消耗 CPU、内存和 I/O 资源；
•client node:client 节点起到路由请求的作用，实际上可以看做负载均衡器。

17.Elasticsearch集群管理之1——如何高效的添加、删除节点？
https://blog.csdn.net/laoyang360/article/details/83218266

Elasticsearch的jvm.properties的配置详解
-XX:+UseConcMarkSweepGC：设置年老代为并发收集。配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置
XX:CMSInitiatingOccupancyFraction=75：表示年老代空间到70%时就开始执行CMS，确保年老代有足够的空间接纳来自年轻代的对象
XX:+UseCMSInitiatingOccupancyOnly：使用手动定义初始化定义开始CMS收集，禁止hostspot自行触发CMS GC
XX:+AlwaysPreTouch：JVM就会先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM.后续JVM就可以顺畅的访问内存了
-server：server模式运行
Xss1m：每个线程的堆栈大小1m
Djava.awt.headless=true:对于一个Java服务器来说经常要处理一些图形元素，这些API基本上总是需要运行一个X-server以便能使用AWT。然而，运行一个不必要的X-server并不是一种好的网络管理方式。开启此配置可以禁用X-server
Dfile.encoding=UTF-8：编码为utf8编码
Djna.nosys=true：始终使用提供的JNA与系统之一
Dio.netty.noUnsafe=true：使用Heap堆内存创建ByteBuf
Dio.netty.noKeySetOptimization=true：没有密钥集
Dio.netty.recycler.maxCapacityPerThread： netty回收配置，每个线程最大容量
Dlog4j.shutdownHookEnabled：log4j配置，是否允许关闭hook
Dlog4j2.disable.jmx: 是否禁用jmx
Dlog4j.skipJansi: ConsoleAppender不会尝试在Windows上使用Jansi输出流
XX:+HeapDumpOnOutOfMemoryError: 输出Heap Dump到指定文件
Xmx: 初始堆大小
Xmx: 最大堆大小 基本上这个配置也就修改一下堆大小，其他配置一般不需要修改。
